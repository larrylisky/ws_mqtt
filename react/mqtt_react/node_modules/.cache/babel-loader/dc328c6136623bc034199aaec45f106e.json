{"ast":null,"code":"'use strict';\n/**\r\n * Module dependencies\r\n */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Store = require('./store');\n\nvar mqttPacket = require('mqtt-packet');\n\nvar Writable = require('readable-stream').Writable;\n\nvar inherits = require('inherits');\n\nvar reInterval = require('reinterval');\n\nvar validations = require('./validations');\n\nvar xtend = require('xtend');\n\nvar debug = require('debug')('mqttjs:client');\n\nvar nextTick = process ? process.nextTick : function (callback) {\n  setTimeout(callback, 0);\n};\n\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback);\n};\n\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\nvar socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND']; // Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nvar errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n};\n\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\n\nfunction sendPacket(client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet);\n  debug('sendPacket :: emitting `packetsend`');\n  client.emit('packetsend', packet);\n  debug('sendPacket :: writing to stream');\n  var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n  debug('sendPacket :: writeToStream result %s', result);\n\n  if (!result && cb) {\n    debug('sendPacket :: handle events on `drain` once through callback.');\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    debug('sendPacket :: invoking cb');\n    cb();\n  }\n}\n\nfunction flush(queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!queue);\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction flushVolatile(queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction storeAndSend(client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n  client.outgoingStore.put(packet, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    cbStorePut();\n    sendPacket(client, packet, cb);\n  });\n}\n\nfunction nop(error) {\n  debug('nop ::', error);\n}\n/**\r\n * MqttClient constructor\r\n *\r\n * @param {Stream} stream - stream\r\n * @param {Object} [options] - connection options\r\n * (see Connection#connect)\r\n */\n\n\nfunction MqttClient(streamBuilder, options) {\n  var k;\n  var that = this;\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n\n  this.options = options || {}; // Defaults\n\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol);\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n  debug('MqttClient :: options.username', options.username);\n  debug('MqttClient :: options.keepalive', options.keepalive);\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n  this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n  debug('MqttClient :: clientId', this.options.clientId);\n  this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n    arguments[3](0);\n  };\n  this.streamBuilder = streamBuilder; // Inflight message storages\n\n  this.outgoingStore = options.outgoingStore || new Store();\n  this.incomingStore = options.incomingStore || new Store(); // Should QoS zero messages be queued when the connection is broken?\n\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero; // map of subscribed topics to support reconnection\n\n  this._resubscribeTopics = {}; // map of a subscribe messageId and a topic\n\n  this.messageIdToTopic = {}; // Ping timer, setup in _setupPingTimer\n\n  this.pingTimer = null; // Is the client connected?\n\n  this.connected = false; // Are we disconnecting?\n\n  this.disconnecting = false; // Packet queue\n\n  this.queue = []; // connack timer\n\n  this.connackTimer = null; // Reconnect timer\n\n  this.reconnectTimer = null; // Is processing store?\n\n  this._storeProcessing = false; // Packet Ids are put into the store during store processing\n\n  this._packetIdsDuringStoreProcessing = {};\n  /**\r\n   * MessageIDs starting with 1\r\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\r\n   */\n\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535)); // Inflight callbacks\n\n  this.outgoing = {}; // True if connection is first time.\n\n  this._firstConnection = true; // Send queued packets\n\n  this.on('connect', function () {\n    var queue = this.queue;\n\n    function deliver() {\n      var entry = queue.shift();\n      debug('deliver :: entry %o', entry);\n      var packet = null;\n\n      if (!entry) {\n        return;\n      }\n\n      packet = entry.packet;\n      debug('deliver :: call _sendPacket for %o', packet);\n\n      that._sendPacket(packet, function (err) {\n        if (entry.cb) {\n          entry.cb(err);\n        }\n\n        deliver();\n      });\n    }\n\n    debug('connect :: sending queued packets');\n    deliver();\n  });\n  this.on('close', function () {\n    debug('close :: connected set to `false`');\n    this.connected = false;\n    debug('close :: clearing connackTimer');\n    clearTimeout(this.connackTimer);\n    debug('close :: clearing ping timer');\n\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n\n    debug('close :: calling _setupReconnect');\n\n    this._setupReconnect();\n  });\n  EventEmitter.call(this);\n  debug('MqttClient :: setting up stream');\n\n  this._setupStream();\n}\n\ninherits(MqttClient, EventEmitter);\n/**\r\n * setup the event handlers in the inner stream.\r\n *\r\n * @api private\r\n */\n\nMqttClient.prototype._setupStream = function () {\n  var connectPacket;\n  var that = this;\n  var writable = new Writable();\n  var parser = mqttPacket.parser(this.options);\n  var completeParse = null;\n  var packets = [];\n  debug('_setupStream :: calling method to clear reconnect');\n\n  this._clearReconnect();\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream');\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.');\n    packets.push(packet);\n  });\n\n  function nextTickWork() {\n    if (packets.length) {\n      nextTick(work);\n    } else {\n      var done = completeParse;\n      completeParse = null;\n      done();\n    }\n  }\n\n  function work() {\n    debug('work :: getting next packet in queue');\n    var packet = packets.shift();\n\n    if (packet) {\n      debug('work :: packet pulled from queue');\n\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      debug('work :: no packets in queue');\n      var done = completeParse;\n      completeParse = null;\n      debug('work :: done flag is %s', !!done);\n      if (done) done();\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    debug('writable stream :: parsing buffer');\n    parser.parse(buf);\n    work();\n  };\n\n  function streamErrorHandler(error) {\n    debug('streamErrorHandler :: error', error.message);\n\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error');\n      that.emit('error', error);\n    } else {\n      nop(error);\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream');\n  this.stream.pipe(writable); // Suppress connection errors\n\n  this.stream.on('error', streamErrorHandler); // Echo stream close\n\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId);\n    flushVolatile(that.outgoing);\n    debug('stream: emit close to MqttClient');\n    that.emit('close');\n  }); // Send a connect packet\n\n  debug('_setupStream: sending packet `connect`');\n  connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect'; // avoid message queue\n\n  sendPacket(this, connectPacket); // Echo connection errors\n\n  parser.on('error', this.emit.bind(this, 'error')); // auth\n\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n      return this;\n    }\n\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      var authPacket = xtend({\n        cmd: 'auth',\n        reasonCode: 0\n      }, this.options.authPacket);\n      sendPacket(this, authPacket);\n    }\n  } // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\n\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  var options = this.options;\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n    this.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return this;\n  }\n\n  debug('_handlePacket :: emitting packetreceive');\n  this.emit('packetreceive', packet);\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n\n      break;\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n\n      done();\n      break;\n\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n\n      break;\n\n    case 'connack':\n      this._handleConnack(packet);\n\n      done();\n      break;\n\n    case 'pingresp':\n      this._handlePingresp(packet);\n\n      done();\n      break;\n\n    case 'disconnect':\n      this._handleDisconnect(packet);\n\n      done();\n      break;\n\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n\n  return this.disconnecting;\n};\n/**\r\n * publish - publish <message> to <topic>\r\n *\r\n * @param {String} topic - topic to publish to\r\n * @param {String, Buffer} message - message to publish\r\n * @param {Object} [opts] - publish options, includes:\r\n *    {Number} qos - qos level to publish on\r\n *    {Boolean} retain - whether or not to retain the message\r\n *    {Boolean} dup - whether or not mark a message as duplicate\r\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\r\n * @param {Function} [callback] - function(err){}\r\n *    called when publish succeeds or fails\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.publish('topic', 'message');\r\n * @example\r\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\r\n * @example client.publish('topic', 'message', console.log);\r\n */\n\n\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic);\n  var packet;\n  var options = this.options; // .publish(topic, payload, cb);\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  } // default opts\n\n\n  var defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  };\n\n  if (options.protocolVersion === 5) {\n    packet.properties = opts.properties;\n\n    if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum || !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n      /*\r\n      if we are don`t setup topic alias or\r\n      topic alias maximum less than topic alias or\r\n      server don`t give topic alias maximum,\r\n      we are removing topic alias from packet\r\n      */\n      delete packet.properties.topicAlias;\n    }\n  }\n\n  debug('publish :: qos', opts.qos);\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = {\n        volatile: false,\n        cb: callback || nop\n      };\n\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled');\n        this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n\n        this._storePacket(packet, undefined, opts.cbStorePut);\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n        this._sendPacket(packet, undefined, opts.cbStorePut);\n      }\n\n      break;\n\n    default:\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled');\n\n        this._storePacket(packet, callback, opts.cbStorePut);\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n        this._sendPacket(packet, callback, opts.cbStorePut);\n      }\n\n      break;\n  }\n\n  return this;\n};\n/**\r\n * subscribe - subscribe to <topic>\r\n *\r\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Number} qos - subscribe qos level\r\n * @param {Function} [callback] - function(err, granted){} where:\r\n *    {Error} err - subscription error (none at the moment!)\r\n *    {Array} granted - array of {topic: 't', qos: 0}\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.subscribe('topic');\r\n * @example client.subscribe('topic', {qos: 1});\r\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\r\n * @example client.subscribe('topic', console.log);\r\n */\n\n\nMqttClient.prototype.subscribe = function () {\n  var packet;\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  var subs = [];\n  var obj = args.shift();\n  var resubscribe = obj.resubscribe;\n  var callback = args.pop() || nop;\n  var opts = args.pop();\n  var invalidTopic;\n  var that = this;\n  var version = this.options.protocolVersion;\n  delete obj.resubscribe;\n\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  invalidTopic = validations.validateTopics(obj);\n\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true');\n    return this;\n  }\n\n  var defaultOpts = {\n    qos: 0\n  };\n\n  if (version === 5) {\n    defaultOpts.nl = false;\n    defaultOpts.rap = false;\n    defaultOpts.rh = 0;\n  }\n\n  opts = xtend(defaultOpts, opts);\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic);\n\n      if (!that._resubscribeTopics.hasOwnProperty(topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n        var currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = opts.nl;\n          currentOpts.rap = opts.rap;\n          currentOpts.rh = opts.rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n        subs.push(currentOpts);\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      debug('subscribe: object topic %s', k);\n\n      if (!that._resubscribeTopics.hasOwnProperty(k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n        var currentOpts = {\n          topic: k,\n          qos: obj[k].qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = obj[k].nl;\n          currentOpts.rap = obj[k].rap;\n          currentOpts.rh = obj[k].rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        debug('subscribe: pushing `%s` to subs list', currentOpts);\n        subs.push(currentOpts);\n      }\n    });\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  };\n\n  if (opts.properties) {\n    packet.properties = opts.properties;\n  }\n\n  if (!subs.length) {\n    callback(null, []);\n    return;\n  } // subscriptions to resubscribe to in case of disconnect\n\n\n  if (this.options.resubscribe) {\n    debug('subscribe :: resubscribe true');\n    var topics = [];\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        var topic = {\n          qos: sub.qos\n        };\n\n        if (version === 5) {\n          topic.nl = sub.nl || false;\n          topic.rap = sub.rap || false;\n          topic.rh = sub.rh || 0;\n          topic.properties = sub.properties;\n        }\n\n        that._resubscribeTopics[sub.topic] = topic;\n        topics.push(sub.topic);\n      }\n    });\n    that.messageIdToTopic[packet.messageId] = topics;\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: function (err, packet) {\n      if (!err) {\n        var granted = packet.granted;\n\n        for (var i = 0; i < granted.length; i += 1) {\n          subs[i].qos = granted[i];\n        }\n      }\n\n      callback(err, subs);\n    }\n  };\n  debug('subscribe :: call _sendPacket');\n\n  this._sendPacket(packet);\n\n  return this;\n};\n/**\r\n * unsubscribe - unsubscribe from topic(s)\r\n *\r\n * @param {String, Array} topic - topics to unsubscribe from\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Object} properties - properties of unsubscribe packet\r\n * @param {Function} [callback] - callback fired on unsuback\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.unsubscribe('topic');\r\n * @example client.unsubscribe('topic', console.log);\r\n */\n\n\nMqttClient.prototype.unsubscribe = function () {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  };\n  var that = this;\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  var topic = args.shift();\n  var callback = args.pop() || nop;\n  var opts = args.pop();\n\n  if (typeof topic === 'string') {\n    topic = [topic];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic];\n  } else if (Array.isArray(topic)) {\n    packet.unsubscriptions = topic;\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic];\n    });\n  }\n\n  if (typeof opts === 'object' && opts.properties) {\n    packet.properties = opts.properties;\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: callback\n  };\n  debug('unsubscribe: call _sendPacket');\n\n  this._sendPacket(packet);\n\n  return this;\n};\n/**\r\n * end - close connection\r\n *\r\n * @returns {MqttClient} this - for chaining\r\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\r\n * @param {Object} opts - added to the disconnect packet\r\n * @param {Function} cb - called when the client has been closed\r\n *\r\n * @api public\r\n */\n\n\nMqttClient.prototype.end = function (force, opts, cb) {\n  var that = this;\n  debug('end :: (%s)', this.options.clientId);\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop;\n    opts = force;\n    force = false;\n\n    if (typeof opts !== 'object') {\n      cb = opts;\n      opts = null;\n\n      if (typeof cb !== 'function') {\n        cb = nop;\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts;\n    opts = null;\n  }\n\n  debug('end :: cb? %s', !!cb);\n  cb = cb || nop;\n\n  function closeStores() {\n    debug('end :: closeStores: closing incoming and outgoing stores');\n    that.disconnected = true;\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end');\n        that.emit('end');\n\n        if (cb) {\n          let err = e1 || e2;\n          debug('end :: closeStores: invoking callback with args');\n          cb(err);\n        }\n      });\n    });\n\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores'); // var boundProcess = nextTick.bind(null, closeStores)\n\n      nextTick(closeStores.bind(that));\n    }, opts);\n  }\n\n  if (this.disconnecting) {\n    cb();\n    return this;\n  }\n\n  this._clearReconnect();\n\n  this.disconnecting = true;\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n    finish();\n  }\n\n  return this;\n};\n/**\r\n * removeOutgoingMessage - remove a message in outgoing store\r\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\r\n *\r\n * @param {Number} messageId - messageId to remove message\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.removeOutgoingMessage(client.getLastMessageId());\r\n */\n\n\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  delete this.outgoing[messageId];\n  this.outgoingStore.del({\n    messageId: messageId\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n/**\r\n * reconnect - connect again using the same options as connect()\r\n *\r\n * @param {Object} [opts] - optional reconnect options, includes:\r\n *    {Store} incomingStore - a store for the incoming packets\r\n *    {Store} outgoingStore - a store for the outgoing packets\r\n *    if opts is not given, current stores are used\r\n * @returns {MqttClient} this - for chaining\r\n *\r\n * @api public\r\n */\n\n\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect');\n  var that = this;\n\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n\n    that._reconnect();\n  };\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n\n  return this;\n};\n/**\r\n * _reconnect - implement reconnection\r\n * @api privateish\r\n */\n\n\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client');\n  this.emit('reconnect');\n\n  if (this.connected) {\n    this.end(() => {\n      this._setupStream();\n    });\n    debug('client already connected. disconnecting first.');\n  } else {\n    debug('_reconnect: calling _setupStream');\n\n    this._setupStream();\n  }\n};\n/**\r\n * _setupReconnect - setup reconnect timer\r\n */\n\n\nMqttClient.prototype._setupReconnect = function () {\n  var that = this;\n\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state');\n      this.emit('offline');\n      debug('_setupReconnect :: set `reconnecting` to `true`');\n      this.reconnecting = true;\n    }\n\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!');\n\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  } else {\n    debug('_setupReconnect :: doing nothing...');\n  }\n};\n/**\r\n * _clearReconnect - clear the reconnect timer\r\n */\n\n\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer');\n\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n/**\r\n * _cleanUp - clean up on connection end\r\n * @api private\r\n */\n\n\nMqttClient.prototype._cleanUp = function (forced, done) {\n  var opts = arguments[2];\n\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close');\n    this.stream.on('close', done);\n  }\n\n  debug('_cleanUp :: forced? %s', forced);\n\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n    this.stream.destroy();\n  } else {\n    var packet = xtend({\n      cmd: 'disconnect'\n    }, opts);\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n\n    this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n\n    this._clearReconnect();\n\n    this._setupReconnect();\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer');\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n/**\r\n * _sendPacket - send or queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\n\n\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n  cbStorePut = cbStorePut || nop;\n\n  if (!this.connected) {\n    debug('_sendPacket :: client not connected. Storing packet offline.');\n\n    this._storePacket(packet, cb, cbStorePut);\n\n    return;\n  } // When sending a packet, reschedule the ping timer\n\n\n  this._shiftPingInterval();\n\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut);\n      return;\n\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut);\n      break;\n\n    /**\r\n     * no need of case here since it will be caught by default\r\n     * and jshint comply that before default it must be a break\r\n     * anyway it will result in -1 evaluation\r\n     */\n\n    case 0:\n    /* falls through */\n\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n};\n/**\r\n * _storePacket - queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\n\n\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet);\n  debug('_storePacket :: cb? %s', !!cb);\n  cbStorePut = cbStorePut || nop; // check that the packet is not a qos of 0, or that the command is not a publish\n\n  if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n    this.queue.push({\n      packet: packet,\n      cb: cb\n    });\n  } else if (packet.qos > 0) {\n    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n    this.outgoingStore.put(packet, function (err) {\n      if (err) {\n        return cb && cb(err);\n      }\n\n      cbStorePut();\n    });\n  } else if (cb) {\n    cb(new Error('No connection to broker'));\n  }\n};\n/**\r\n * _setupPingTimer - setup the ping timer\r\n *\r\n * @api private\r\n */\n\n\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n  var that = this;\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n/**\r\n * _shiftPingInterval - reschedule the ping interval\r\n *\r\n * @api private\r\n */\n\n\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\r\n * _checkPing - check if a pingresp has come back, and ping the server again\r\n *\r\n * @api private\r\n */\n\n\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...');\n\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n    this.pingResp = false;\n\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true');\n\n    this._cleanUp(true);\n  }\n};\n/**\r\n * _handlePingresp - handle a pingresp\r\n *\r\n * @api private\r\n */\n\n\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n/**\r\n * _handleConnack\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\n\n\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack');\n  var options = this.options;\n  var version = options.protocolVersion;\n  var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  clearTimeout(this.connackTimer);\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n\n      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n    }\n\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive;\n\n      this._shiftPingInterval();\n    }\n\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false;\n\n    this._onConnect(packet);\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\n/**\r\n * _handlePublish\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\n\n/*\r\nthose late 2 case should be rewrite to comply with coding style:\r\n\r\ncase 1:\r\ncase 0:\r\n  // do not wait sending a puback\r\n  // no callback passed\r\n  if (1 === qos) {\r\n    this._sendPacket({\r\n      cmd: 'puback',\r\n      messageId: messageId\r\n    });\r\n  }\r\n  // emit the message event for both qos 1 and 0\r\n  this.emit('message', topic, message, packet);\r\n  this.handleMessage(packet, done);\r\n  break;\r\ndefault:\r\n  // do nothing but every switch mus have a default\r\n  // log or throw an error about unknown qos\r\n  break;\r\n\r\nfor now i just suppressed the warnings\r\n*/\n\n\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet);\n  done = typeof done !== 'undefined' ? done : nop;\n  var topic = packet.topic.toString();\n  var message = packet.payload;\n  var qos = packet.qos;\n  var messageId = packet.messageId;\n  var that = this;\n  var options = this.options;\n  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n  debug('_handlePublish: qos %d', qos);\n\n  switch (qos) {\n    case 2:\n      {\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for pubrec'));\n          }\n\n          if (code) {\n            that._sendPacket({\n              cmd: 'pubrec',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          } else {\n            that.incomingStore.put(packet, function () {\n              that._sendPacket({\n                cmd: 'pubrec',\n                messageId: messageId\n              }, done);\n            });\n          }\n        });\n        break;\n      }\n\n    case 1:\n      {\n        // emit the message event\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for puback'));\n          }\n\n          if (!code) {\n            that.emit('message', topic, message, packet);\n          }\n\n          that.handleMessage(packet, function (err) {\n            if (err) {\n              return done && done(err);\n            }\n\n            that._sendPacket({\n              cmd: 'puback',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          });\n        });\n        break;\n      }\n\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.'); // log or throw an error about unknown qos\n\n      break;\n  }\n};\n/**\r\n * Handle messages with backpressure support, one at a time.\r\n * Override at will.\r\n *\r\n * @param Packet packet the packet\r\n * @param Function callback call when finished\r\n * @api public\r\n */\n\n\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n/**\r\n * _handleAck\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\n\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var messageId = packet.messageId;\n  var type = packet.cmd;\n  var response = null;\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  var that = this;\n  var err;\n\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.'); // Server sent an ack in error, ignore it.\n\n    return;\n  } // Process\n\n\n  debug('_handleAck :: packet type', type);\n\n  switch (type) {\n    case 'pubcomp': // same thing as puback for QoS 2\n\n    case 'puback':\n      var pubackRC = packet.reasonCode; // Callback - we're done\n\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC]);\n        err.code = pubackRC;\n        cb(err, packet);\n      }\n\n      delete this.outgoing[messageId];\n      this.outgoingStore.del(packet, cb);\n      break;\n\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: messageId\n      };\n      var pubrecRC = packet.reasonCode;\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC]);\n        err.code = pubrecRC;\n        cb(err, packet);\n      } else {\n        this._sendPacket(response);\n      }\n\n      break;\n\n    case 'suback':\n      delete this.outgoing[messageId];\n\n      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          var topics = this.messageIdToTopic[messageId];\n\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic];\n            });\n          }\n        }\n      }\n\n      cb(null, packet);\n      break;\n\n    case 'unsuback':\n      delete this.outgoing[messageId];\n      cb(null);\n      break;\n\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n/**\r\n * _handlePubrel\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\n\n\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet');\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  var messageId = packet.messageId;\n  var that = this;\n  var comp = {\n    cmd: 'pubcomp',\n    messageId: messageId\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        that.incomingStore.del(pub, nop);\n\n        that._sendPacket(comp, callback);\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n/**\r\n * _handleDisconnect\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\n\n\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet);\n};\n/**\r\n * _nextId\r\n * @return unsigned int\r\n */\n\n\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++; // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n\n  if (this.nextId === 65536) {\n    this.nextId = 1;\n  }\n\n  return id;\n};\n/**\r\n * getLastMessageId\r\n * @return unsigned int\r\n */\n\n\nMqttClient.prototype.getLastMessageId = function () {\n  return this.nextId === 1 ? 65535 : this.nextId - 1;\n};\n/**\r\n * _resubscribe\r\n * @api private\r\n */\n\n\nMqttClient.prototype._resubscribe = function (connack) {\n  debug('_resubscribe');\n\n  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n\n  if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5');\n\n        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          var resubscribeTopic = {};\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n          resubscribeTopic.resubscribe = true;\n          this.subscribe(resubscribeTopic, {\n            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n          });\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      }\n    } else {\n      this._resubscribeTopics = {};\n    }\n  }\n\n  this._firstConnection = false;\n};\n/**\r\n * _onConnect\r\n *\r\n * @api private\r\n */\n\n\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet);\n    return;\n  }\n\n  var that = this;\n\n  this._setupPingTimer();\n\n  this._resubscribe(packet);\n\n  this.connected = true;\n\n  function startStreamProcess() {\n    var outStore = that.outgoingStore.createStream();\n\n    function clearStoreProcessing() {\n      that._storeProcessing = false;\n      that._packetIdsDuringStoreProcessing = {};\n    }\n\n    that.once('close', remove);\n    outStore.on('error', function (err) {\n      clearStoreProcessing();\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n      clearStoreProcessing();\n    }\n\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n\n      that._storeProcessing = true;\n      var packet = outStore.read(1);\n      var cb;\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      } // Skip already processed store packets\n\n\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver();\n        return;\n      } // Avoid unnecessary stream read operations when disconnected\n\n\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status);\n            }\n\n            storeDeliver();\n          }\n        };\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n\n        that._sendPacket(packet);\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    }\n\n    outStore.on('end', function () {\n      var allProcessed = true;\n\n      for (var id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false;\n          break;\n        }\n      }\n\n      if (allProcessed) {\n        clearStoreProcessing();\n        that.removeListener('close', remove);\n        that.emit('connect', packet);\n      } else {\n        startStreamProcess();\n      }\n    });\n    storeDeliver();\n  } // start flowing\n\n\n  startStreamProcess();\n};\n\nmodule.exports = MqttClient;","map":{"version":3,"sources":["/Users/larry/Software/react/mqtt_react/node_modules/mqtt/lib/client.js"],"names":["EventEmitter","require","Store","mqttPacket","Writable","inherits","reInterval","validations","xtend","debug","nextTick","process","callback","setTimeout","setImmediate","global","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","socketErrors","errors","defaultId","Math","random","toString","substr","sendPacket","client","packet","cb","emit","result","writeToStream","stream","options","once","flush","queue","Object","keys","forEach","messageId","Error","flushVolatile","volatile","storeAndSend","cbStorePut","cmd","outgoingStore","put","storedPacket","err","nop","error","MqttClient","streamBuilder","k","that","protocol","username","rejectUnauthorized","clientId","customHandleAcks","arguments","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","nextId","max","floor","outgoing","_firstConnection","on","deliver","entry","shift","_sendPacket","clearTimeout","clear","_setupReconnect","call","_setupStream","prototype","connectPacket","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","length","work","done","_handlePacket","_write","buf","enc","parse","streamErrorHandler","message","includes","code","pipe","create","bind","properties","authenticationMethod","authenticationData","end","authPacket","reasonCode","setMaxListeners","_cleanUp","maximumPacketSize","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","topic","opts","defaultOpts","qos","retain","dup","payload","_nextId","topicAlias","topicAliasMaximum","_storePacket","subscribe","args","Array","i","subs","obj","pop","invalidTopic","version","validateTopics","nl","rap","rh","isArray","hasOwnProperty","currentOpts","subscriptions","topics","sub","granted","unsubscribe","unsubscriptions","force","closeStores","disconnected","close","e1","e2","_deferredReconnect","finish","removeOutgoingMessage","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","removeListener","_shiftPingInterval","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","validReasonCodes","indexOf","handleMessage","type","response","pubackRC","pubrecRC","grantedI","comp","get","pub","id","getLastMessageId","_resubscribe","connack","_resubscribeTopicsKeys","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","storeDeliver","read","status","allProcessed","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n/**\r\n * Module dependencies\r\n */\r\nvar EventEmitter = require('events').EventEmitter\r\nvar Store = require('./store')\r\nvar mqttPacket = require('mqtt-packet')\r\nvar Writable = require('readable-stream').Writable\r\nvar inherits = require('inherits')\r\nvar reInterval = require('reinterval')\r\nvar validations = require('./validations')\r\nvar xtend = require('xtend')\r\nvar debug = require('debug')('mqttjs:client')\r\nvar nextTick = process ? process.nextTick : function (callback) { setTimeout(callback, 0) }\r\nvar setImmediate = global.setImmediate || function (callback) {\r\n  // works in node v0.8\r\n  nextTick(callback)\r\n}\r\nvar defaultConnectOptions = {\r\n  keepalive: 60,\r\n  reschedulePings: true,\r\n  protocolId: 'MQTT',\r\n  protocolVersion: 4,\r\n  reconnectPeriod: 1000,\r\n  connectTimeout: 30 * 1000,\r\n  clean: true,\r\n  resubscribe: true\r\n}\r\n\r\nvar socketErrors = [\r\n  'ECONNREFUSED',\r\n  'EADDRINUSE',\r\n  'ECONNRESET',\r\n  'ENOTFOUND'\r\n]\r\n\r\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\r\n\r\nvar errors = {\r\n  0: '',\r\n  1: 'Unacceptable protocol version',\r\n  2: 'Identifier rejected',\r\n  3: 'Server unavailable',\r\n  4: 'Bad username or password',\r\n  5: 'Not authorized',\r\n  16: 'No matching subscribers',\r\n  17: 'No subscription existed',\r\n  128: 'Unspecified error',\r\n  129: 'Malformed Packet',\r\n  130: 'Protocol Error',\r\n  131: 'Implementation specific error',\r\n  132: 'Unsupported Protocol Version',\r\n  133: 'Client Identifier not valid',\r\n  134: 'Bad User Name or Password',\r\n  135: 'Not authorized',\r\n  136: 'Server unavailable',\r\n  137: 'Server busy',\r\n  138: 'Banned',\r\n  139: 'Server shutting down',\r\n  140: 'Bad authentication method',\r\n  141: 'Keep Alive timeout',\r\n  142: 'Session taken over',\r\n  143: 'Topic Filter invalid',\r\n  144: 'Topic Name invalid',\r\n  145: 'Packet identifier in use',\r\n  146: 'Packet Identifier not found',\r\n  147: 'Receive Maximum exceeded',\r\n  148: 'Topic Alias invalid',\r\n  149: 'Packet too large',\r\n  150: 'Message rate too high',\r\n  151: 'Quota exceeded',\r\n  152: 'Administrative action',\r\n  153: 'Payload format invalid',\r\n  154: 'Retain not supported',\r\n  155: 'QoS not supported',\r\n  156: 'Use another server',\r\n  157: 'Server moved',\r\n  158: 'Shared Subscriptions not supported',\r\n  159: 'Connection rate exceeded',\r\n  160: 'Maximum connect time',\r\n  161: 'Subscription Identifiers not supported',\r\n  162: 'Wildcard Subscriptions not supported'\r\n}\r\n\r\nfunction defaultId () {\r\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\r\n}\r\n\r\nfunction sendPacket (client, packet, cb) {\r\n  debug('sendPacket :: packet: %O', packet)\r\n  debug('sendPacket :: emitting `packetsend`')\r\n  client.emit('packetsend', packet)\r\n\r\n  debug('sendPacket :: writing to stream')\r\n  var result = mqttPacket.writeToStream(packet, client.stream, client.options)\r\n  debug('sendPacket :: writeToStream result %s', result)\r\n  if (!result && cb) {\r\n    debug('sendPacket :: handle events on `drain` once through callback.')\r\n    client.stream.once('drain', cb)\r\n  } else if (cb) {\r\n    debug('sendPacket :: invoking cb')\r\n    cb()\r\n  }\r\n}\r\n\r\nfunction flush (queue) {\r\n  if (queue) {\r\n    debug('flush: queue exists? %b', !!(queue))\r\n    Object.keys(queue).forEach(function (messageId) {\r\n      if (typeof queue[messageId].cb === 'function') {\r\n        queue[messageId].cb(new Error('Connection closed'))\r\n        delete queue[messageId]\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction flushVolatile (queue) {\r\n  if (queue) {\r\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')\r\n    Object.keys(queue).forEach(function (messageId) {\r\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\r\n        queue[messageId].cb(new Error('Connection closed'))\r\n        delete queue[messageId]\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction storeAndSend (client, packet, cb, cbStorePut) {\r\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)\r\n  client.outgoingStore.put(packet, function storedPacket (err) {\r\n    if (err) {\r\n      return cb && cb(err)\r\n    }\r\n    cbStorePut()\r\n    sendPacket(client, packet, cb)\r\n  })\r\n}\r\n\r\nfunction nop (error) {\r\n  debug('nop ::', error)\r\n}\r\n\r\n/**\r\n * MqttClient constructor\r\n *\r\n * @param {Stream} stream - stream\r\n * @param {Object} [options] - connection options\r\n * (see Connection#connect)\r\n */\r\nfunction MqttClient (streamBuilder, options) {\r\n  var k\r\n  var that = this\r\n\r\n  if (!(this instanceof MqttClient)) {\r\n    return new MqttClient(streamBuilder, options)\r\n  }\r\n\r\n  this.options = options || {}\r\n\r\n  // Defaults\r\n  for (k in defaultConnectOptions) {\r\n    if (typeof this.options[k] === 'undefined') {\r\n      this.options[k] = defaultConnectOptions[k]\r\n    } else {\r\n      this.options[k] = options[k]\r\n    }\r\n  }\r\n\r\n  debug('MqttClient :: options.protocol', options.protocol)\r\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion)\r\n  debug('MqttClient :: options.username', options.username)\r\n  debug('MqttClient :: options.keepalive', options.keepalive)\r\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)\r\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)\r\n\r\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\r\n\r\n  debug('MqttClient :: clientId', this.options.clientId)\r\n\r\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\r\n\r\n  this.streamBuilder = streamBuilder\r\n\r\n  // Inflight message storages\r\n  this.outgoingStore = options.outgoingStore || new Store()\r\n  this.incomingStore = options.incomingStore || new Store()\r\n\r\n  // Should QoS zero messages be queued when the connection is broken?\r\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\r\n\r\n  // map of subscribed topics to support reconnection\r\n  this._resubscribeTopics = {}\r\n\r\n  // map of a subscribe messageId and a topic\r\n  this.messageIdToTopic = {}\r\n\r\n  // Ping timer, setup in _setupPingTimer\r\n  this.pingTimer = null\r\n  // Is the client connected?\r\n  this.connected = false\r\n  // Are we disconnecting?\r\n  this.disconnecting = false\r\n  // Packet queue\r\n  this.queue = []\r\n  // connack timer\r\n  this.connackTimer = null\r\n  // Reconnect timer\r\n  this.reconnectTimer = null\r\n  // Is processing store?\r\n  this._storeProcessing = false\r\n  // Packet Ids are put into the store during store processing\r\n  this._packetIdsDuringStoreProcessing = {}\r\n  /**\r\n   * MessageIDs starting with 1\r\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\r\n   */\r\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\r\n\r\n  // Inflight callbacks\r\n  this.outgoing = {}\r\n\r\n  // True if connection is first time.\r\n  this._firstConnection = true\r\n\r\n  // Send queued packets\r\n  this.on('connect', function () {\r\n    var queue = this.queue\r\n\r\n    function deliver () {\r\n      var entry = queue.shift()\r\n      debug('deliver :: entry %o', entry)\r\n      var packet = null\r\n\r\n      if (!entry) {\r\n        return\r\n      }\r\n\r\n      packet = entry.packet\r\n      debug('deliver :: call _sendPacket for %o', packet)\r\n      that._sendPacket(\r\n        packet,\r\n        function (err) {\r\n          if (entry.cb) {\r\n            entry.cb(err)\r\n          }\r\n          deliver()\r\n        }\r\n      )\r\n    }\r\n\r\n    debug('connect :: sending queued packets')\r\n    deliver()\r\n  })\r\n\r\n  this.on('close', function () {\r\n    debug('close :: connected set to `false`')\r\n    this.connected = false\r\n\r\n    debug('close :: clearing connackTimer')\r\n    clearTimeout(this.connackTimer)\r\n\r\n    debug('close :: clearing ping timer')\r\n    if (that.pingTimer !== null) {\r\n      that.pingTimer.clear()\r\n      that.pingTimer = null\r\n    }\r\n\r\n    debug('close :: calling _setupReconnect')\r\n    this._setupReconnect()\r\n  })\r\n  EventEmitter.call(this)\r\n\r\n  debug('MqttClient :: setting up stream')\r\n  this._setupStream()\r\n}\r\ninherits(MqttClient, EventEmitter)\r\n\r\n/**\r\n * setup the event handlers in the inner stream.\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._setupStream = function () {\r\n  var connectPacket\r\n  var that = this\r\n  var writable = new Writable()\r\n  var parser = mqttPacket.parser(this.options)\r\n  var completeParse = null\r\n  var packets = []\r\n\r\n  debug('_setupStream :: calling method to clear reconnect')\r\n  this._clearReconnect()\r\n\r\n  debug('_setupStream :: using streamBuilder provided to client to create stream')\r\n  this.stream = this.streamBuilder(this)\r\n\r\n  parser.on('packet', function (packet) {\r\n    debug('parser :: on packet push to packets array.')\r\n    packets.push(packet)\r\n  })\r\n\r\n  function nextTickWork () {\r\n    if (packets.length) {\r\n      nextTick(work)\r\n    } else {\r\n      var done = completeParse\r\n      completeParse = null\r\n      done()\r\n    }\r\n  }\r\n\r\n  function work () {\r\n    debug('work :: getting next packet in queue')\r\n    var packet = packets.shift()\r\n\r\n    if (packet) {\r\n      debug('work :: packet pulled from queue')\r\n      that._handlePacket(packet, nextTickWork)\r\n    } else {\r\n      debug('work :: no packets in queue')\r\n      var done = completeParse\r\n      completeParse = null\r\n      debug('work :: done flag is %s', !!(done))\r\n      if (done) done()\r\n    }\r\n  }\r\n\r\n  writable._write = function (buf, enc, done) {\r\n    completeParse = done\r\n    debug('writable stream :: parsing buffer')\r\n    parser.parse(buf)\r\n    work()\r\n  }\r\n\r\n  function streamErrorHandler (error) {\r\n    debug('streamErrorHandler :: error', error.message)\r\n    if (socketErrors.includes(error.code)) {\r\n      // handle error\r\n      debug('streamErrorHandler :: emitting error')\r\n      that.emit('error', error)\r\n    } else {\r\n      nop(error)\r\n    }\r\n  }\r\n\r\n  debug('_setupStream :: pipe stream to writable stream')\r\n  this.stream.pipe(writable)\r\n\r\n  // Suppress connection errors\r\n  this.stream.on('error', streamErrorHandler)\r\n\r\n  // Echo stream close\r\n  this.stream.on('close', function () {\r\n    debug('(%s)stream :: on close', that.options.clientId)\r\n    flushVolatile(that.outgoing)\r\n    debug('stream: emit close to MqttClient')\r\n    that.emit('close')\r\n  })\r\n\r\n  // Send a connect packet\r\n  debug('_setupStream: sending packet `connect`')\r\n  connectPacket = Object.create(this.options)\r\n  connectPacket.cmd = 'connect'\r\n  // avoid message queue\r\n  sendPacket(this, connectPacket)\r\n\r\n  // Echo connection errors\r\n  parser.on('error', this.emit.bind(this, 'error'))\r\n\r\n  // auth\r\n  if (this.options.properties) {\r\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\r\n      that.end(() =>\r\n        this.emit('error', new Error('Packet has no Authentication Method')\r\n        ))\r\n      return this\r\n    }\r\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\r\n      var authPacket = xtend({cmd: 'auth', reasonCode: 0}, this.options.authPacket)\r\n      sendPacket(this, authPacket)\r\n    }\r\n  }\r\n\r\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\r\n  this.stream.setMaxListeners(1000)\r\n\r\n  clearTimeout(this.connackTimer)\r\n  this.connackTimer = setTimeout(function () {\r\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')\r\n    that._cleanUp(true)\r\n  }, this.options.connectTimeout)\r\n}\r\n\r\nMqttClient.prototype._handlePacket = function (packet, done) {\r\n  var options = this.options\r\n\r\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\r\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\r\n    this.end({reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' }})\r\n    return this\r\n  }\r\n  debug('_handlePacket :: emitting packetreceive')\r\n  this.emit('packetreceive', packet)\r\n\r\n  switch (packet.cmd) {\r\n    case 'publish':\r\n      this._handlePublish(packet, done)\r\n      break\r\n    case 'puback':\r\n    case 'pubrec':\r\n    case 'pubcomp':\r\n    case 'suback':\r\n    case 'unsuback':\r\n      this._handleAck(packet)\r\n      done()\r\n      break\r\n    case 'pubrel':\r\n      this._handlePubrel(packet, done)\r\n      break\r\n    case 'connack':\r\n      this._handleConnack(packet)\r\n      done()\r\n      break\r\n    case 'pingresp':\r\n      this._handlePingresp(packet)\r\n      done()\r\n      break\r\n    case 'disconnect':\r\n      this._handleDisconnect(packet)\r\n      done()\r\n      break\r\n    default:\r\n      // do nothing\r\n      // maybe we should do an error handling\r\n      // or just log it\r\n      break\r\n  }\r\n}\r\n\r\nMqttClient.prototype._checkDisconnecting = function (callback) {\r\n  if (this.disconnecting) {\r\n    if (callback) {\r\n      callback(new Error('client disconnecting'))\r\n    } else {\r\n      this.emit('error', new Error('client disconnecting'))\r\n    }\r\n  }\r\n  return this.disconnecting\r\n}\r\n\r\n/**\r\n * publish - publish <message> to <topic>\r\n *\r\n * @param {String} topic - topic to publish to\r\n * @param {String, Buffer} message - message to publish\r\n * @param {Object} [opts] - publish options, includes:\r\n *    {Number} qos - qos level to publish on\r\n *    {Boolean} retain - whether or not to retain the message\r\n *    {Boolean} dup - whether or not mark a message as duplicate\r\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\r\n * @param {Function} [callback] - function(err){}\r\n *    called when publish succeeds or fails\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.publish('topic', 'message');\r\n * @example\r\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\r\n * @example client.publish('topic', 'message', console.log);\r\n */\r\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\r\n  debug('publish :: message `%s` to topic `%s`', message, topic)\r\n  var packet\r\n  var options = this.options\r\n\r\n  // .publish(topic, payload, cb);\r\n  if (typeof opts === 'function') {\r\n    callback = opts\r\n    opts = null\r\n  }\r\n\r\n  // default opts\r\n  var defaultOpts = {qos: 0, retain: false, dup: false}\r\n  opts = xtend(defaultOpts, opts)\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    return this\r\n  }\r\n\r\n  packet = {\r\n    cmd: 'publish',\r\n    topic: topic,\r\n    payload: message,\r\n    qos: opts.qos,\r\n    retain: opts.retain,\r\n    messageId: this._nextId(),\r\n    dup: opts.dup\r\n  }\r\n\r\n  if (options.protocolVersion === 5) {\r\n    packet.properties = opts.properties\r\n    if ((!options.properties && packet.properties && packet.properties.topicAlias) || ((opts.properties && options.properties) &&\r\n      ((opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum) ||\r\n        (!options.properties.topicAliasMaximum && opts.properties.topicAlias)))) {\r\n      /*\r\n      if we are don`t setup topic alias or\r\n      topic alias maximum less than topic alias or\r\n      server don`t give topic alias maximum,\r\n      we are removing topic alias from packet\r\n      */\r\n      delete packet.properties.topicAlias\r\n    }\r\n  }\r\n\r\n  debug('publish :: qos', opts.qos)\r\n  switch (opts.qos) {\r\n    case 1:\r\n    case 2:\r\n      // Add to callbacks\r\n      this.outgoing[packet.messageId] = {\r\n        volatile: false,\r\n        cb: callback || nop\r\n      }\r\n      if (this._storeProcessing) {\r\n        debug('_storeProcessing enabled')\r\n        this._packetIdsDuringStoreProcessing[packet.messageId] = false\r\n        this._storePacket(packet, undefined, opts.cbStorePut)\r\n      } else {\r\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\r\n        this._sendPacket(packet, undefined, opts.cbStorePut)\r\n      }\r\n      break\r\n    default:\r\n      if (this._storeProcessing) {\r\n        debug('_storeProcessing enabled')\r\n        this._storePacket(packet, callback, opts.cbStorePut)\r\n      } else {\r\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\r\n        this._sendPacket(packet, callback, opts.cbStorePut)\r\n      }\r\n      break\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * subscribe - subscribe to <topic>\r\n *\r\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Number} qos - subscribe qos level\r\n * @param {Function} [callback] - function(err, granted){} where:\r\n *    {Error} err - subscription error (none at the moment!)\r\n *    {Array} granted - array of {topic: 't', qos: 0}\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.subscribe('topic');\r\n * @example client.subscribe('topic', {qos: 1});\r\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\r\n * @example client.subscribe('topic', console.log);\r\n */\r\nMqttClient.prototype.subscribe = function () {\r\n  var packet\r\n  var args = new Array(arguments.length)\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    args[i] = arguments[i]\r\n  }\r\n  var subs = []\r\n  var obj = args.shift()\r\n  var resubscribe = obj.resubscribe\r\n  var callback = args.pop() || nop\r\n  var opts = args.pop()\r\n  var invalidTopic\r\n  var that = this\r\n  var version = this.options.protocolVersion\r\n\r\n  delete obj.resubscribe\r\n\r\n  if (typeof obj === 'string') {\r\n    obj = [obj]\r\n  }\r\n\r\n  if (typeof callback !== 'function') {\r\n    opts = callback\r\n    callback = nop\r\n  }\r\n\r\n  invalidTopic = validations.validateTopics(obj)\r\n  if (invalidTopic !== null) {\r\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\r\n    return this\r\n  }\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    debug('subscribe: discconecting true')\r\n    return this\r\n  }\r\n\r\n  var defaultOpts = {\r\n    qos: 0\r\n  }\r\n  if (version === 5) {\r\n    defaultOpts.nl = false\r\n    defaultOpts.rap = false\r\n    defaultOpts.rh = 0\r\n  }\r\n  opts = xtend(defaultOpts, opts)\r\n\r\n  if (Array.isArray(obj)) {\r\n    obj.forEach(function (topic) {\r\n      debug('subscribe: array topic %s', topic)\r\n      if (!that._resubscribeTopics.hasOwnProperty(topic) ||\r\n        that._resubscribeTopics[topic].qos < opts.qos ||\r\n          resubscribe) {\r\n        var currentOpts = {\r\n          topic: topic,\r\n          qos: opts.qos\r\n        }\r\n        if (version === 5) {\r\n          currentOpts.nl = opts.nl\r\n          currentOpts.rap = opts.rap\r\n          currentOpts.rh = opts.rh\r\n          currentOpts.properties = opts.properties\r\n        }\r\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)\r\n        subs.push(currentOpts)\r\n      }\r\n    })\r\n  } else {\r\n    Object\r\n      .keys(obj)\r\n      .forEach(function (k) {\r\n        debug('subscribe: object topic %s', k)\r\n        if (!that._resubscribeTopics.hasOwnProperty(k) ||\r\n          that._resubscribeTopics[k].qos < obj[k].qos ||\r\n            resubscribe) {\r\n          var currentOpts = {\r\n            topic: k,\r\n            qos: obj[k].qos\r\n          }\r\n          if (version === 5) {\r\n            currentOpts.nl = obj[k].nl\r\n            currentOpts.rap = obj[k].rap\r\n            currentOpts.rh = obj[k].rh\r\n            currentOpts.properties = opts.properties\r\n          }\r\n          debug('subscribe: pushing `%s` to subs list', currentOpts)\r\n          subs.push(currentOpts)\r\n        }\r\n      })\r\n  }\r\n\r\n  packet = {\r\n    cmd: 'subscribe',\r\n    subscriptions: subs,\r\n    qos: 1,\r\n    retain: false,\r\n    dup: false,\r\n    messageId: this._nextId()\r\n  }\r\n\r\n  if (opts.properties) {\r\n    packet.properties = opts.properties\r\n  }\r\n\r\n  if (!subs.length) {\r\n    callback(null, [])\r\n    return\r\n  }\r\n\r\n  // subscriptions to resubscribe to in case of disconnect\r\n  if (this.options.resubscribe) {\r\n    debug('subscribe :: resubscribe true')\r\n    var topics = []\r\n    subs.forEach(function (sub) {\r\n      if (that.options.reconnectPeriod > 0) {\r\n        var topic = { qos: sub.qos }\r\n        if (version === 5) {\r\n          topic.nl = sub.nl || false\r\n          topic.rap = sub.rap || false\r\n          topic.rh = sub.rh || 0\r\n          topic.properties = sub.properties\r\n        }\r\n        that._resubscribeTopics[sub.topic] = topic\r\n        topics.push(sub.topic)\r\n      }\r\n    })\r\n    that.messageIdToTopic[packet.messageId] = topics\r\n  }\r\n\r\n  this.outgoing[packet.messageId] = {\r\n    volatile: true,\r\n    cb: function (err, packet) {\r\n      if (!err) {\r\n        var granted = packet.granted\r\n        for (var i = 0; i < granted.length; i += 1) {\r\n          subs[i].qos = granted[i]\r\n        }\r\n      }\r\n\r\n      callback(err, subs)\r\n    }\r\n  }\r\n  debug('subscribe :: call _sendPacket')\r\n  this._sendPacket(packet)\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * unsubscribe - unsubscribe from topic(s)\r\n *\r\n * @param {String, Array} topic - topics to unsubscribe from\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Object} properties - properties of unsubscribe packet\r\n * @param {Function} [callback] - callback fired on unsuback\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.unsubscribe('topic');\r\n * @example client.unsubscribe('topic', console.log);\r\n */\r\nMqttClient.prototype.unsubscribe = function () {\r\n  var packet = {\r\n    cmd: 'unsubscribe',\r\n    qos: 1,\r\n    messageId: this._nextId()\r\n  }\r\n  var that = this\r\n  var args = new Array(arguments.length)\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    args[i] = arguments[i]\r\n  }\r\n  var topic = args.shift()\r\n  var callback = args.pop() || nop\r\n  var opts = args.pop()\r\n\r\n  if (typeof topic === 'string') {\r\n    topic = [topic]\r\n  }\r\n\r\n  if (typeof callback !== 'function') {\r\n    opts = callback\r\n    callback = nop\r\n  }\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    return this\r\n  }\r\n\r\n  if (typeof topic === 'string') {\r\n    packet.unsubscriptions = [topic]\r\n  } else if (Array.isArray(topic)) {\r\n    packet.unsubscriptions = topic\r\n  }\r\n\r\n  if (this.options.resubscribe) {\r\n    packet.unsubscriptions.forEach(function (topic) {\r\n      delete that._resubscribeTopics[topic]\r\n    })\r\n  }\r\n\r\n  if (typeof opts === 'object' && opts.properties) {\r\n    packet.properties = opts.properties\r\n  }\r\n\r\n  this.outgoing[packet.messageId] = {\r\n    volatile: true,\r\n    cb: callback\r\n  }\r\n\r\n  debug('unsubscribe: call _sendPacket')\r\n  this._sendPacket(packet)\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * end - close connection\r\n *\r\n * @returns {MqttClient} this - for chaining\r\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\r\n * @param {Object} opts - added to the disconnect packet\r\n * @param {Function} cb - called when the client has been closed\r\n *\r\n * @api public\r\n */\r\nMqttClient.prototype.end = function (force, opts, cb) {\r\n  var that = this\r\n\r\n  debug('end :: (%s)', this.options.clientId)\r\n\r\n  if (force == null || typeof force !== 'boolean') {\r\n    cb = opts || nop\r\n    opts = force\r\n    force = false\r\n    if (typeof opts !== 'object') {\r\n      cb = opts\r\n      opts = null\r\n      if (typeof cb !== 'function') {\r\n        cb = nop\r\n      }\r\n    }\r\n  }\r\n\r\n  if (typeof opts !== 'object') {\r\n    cb = opts\r\n    opts = null\r\n  }\r\n\r\n  debug('end :: cb? %s', !!cb)\r\n  cb = cb || nop\r\n\r\n  function closeStores () {\r\n    debug('end :: closeStores: closing incoming and outgoing stores')\r\n    that.disconnected = true\r\n    that.incomingStore.close(function (e1) {\r\n      that.outgoingStore.close(function (e2) {\r\n        debug('end :: closeStores: emitting end')\r\n        that.emit('end')\r\n        if (cb) {\r\n          let err = e1 || e2\r\n          debug('end :: closeStores: invoking callback with args')\r\n          cb(err)\r\n        }\r\n      })\r\n    })\r\n    if (that._deferredReconnect) {\r\n      that._deferredReconnect()\r\n    }\r\n  }\r\n\r\n  function finish () {\r\n    // defer closesStores of an I/O cycle,\r\n    // just to make sure things are\r\n    // ok for websockets\r\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)\r\n    that._cleanUp(force, () => {\r\n      debug('end :: finish :: calling process.nextTick on closeStores')\r\n      // var boundProcess = nextTick.bind(null, closeStores)\r\n      nextTick(closeStores.bind(that))\r\n    }, opts)\r\n  }\r\n\r\n  if (this.disconnecting) {\r\n    cb()\r\n    return this\r\n  }\r\n\r\n  this._clearReconnect()\r\n\r\n  this.disconnecting = true\r\n\r\n  if (!force && Object.keys(this.outgoing).length > 0) {\r\n    // wait 10ms, just to be sure we received all of it\r\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)\r\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\r\n  } else {\r\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId)\r\n    finish()\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * removeOutgoingMessage - remove a message in outgoing store\r\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\r\n *\r\n * @param {Number} messageId - messageId to remove message\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.removeOutgoingMessage(client.getLastMessageId());\r\n */\r\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\r\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\r\n  delete this.outgoing[messageId]\r\n  this.outgoingStore.del({messageId: messageId}, function () {\r\n    cb(new Error('Message removed'))\r\n  })\r\n  return this\r\n}\r\n\r\n/**\r\n * reconnect - connect again using the same options as connect()\r\n *\r\n * @param {Object} [opts] - optional reconnect options, includes:\r\n *    {Store} incomingStore - a store for the incoming packets\r\n *    {Store} outgoingStore - a store for the outgoing packets\r\n *    if opts is not given, current stores are used\r\n * @returns {MqttClient} this - for chaining\r\n *\r\n * @api public\r\n */\r\nMqttClient.prototype.reconnect = function (opts) {\r\n  debug('client reconnect')\r\n  var that = this\r\n  var f = function () {\r\n    if (opts) {\r\n      that.options.incomingStore = opts.incomingStore\r\n      that.options.outgoingStore = opts.outgoingStore\r\n    } else {\r\n      that.options.incomingStore = null\r\n      that.options.outgoingStore = null\r\n    }\r\n    that.incomingStore = that.options.incomingStore || new Store()\r\n    that.outgoingStore = that.options.outgoingStore || new Store()\r\n    that.disconnecting = false\r\n    that.disconnected = false\r\n    that._deferredReconnect = null\r\n    that._reconnect()\r\n  }\r\n\r\n  if (this.disconnecting && !this.disconnected) {\r\n    this._deferredReconnect = f\r\n  } else {\r\n    f()\r\n  }\r\n  return this\r\n}\r\n\r\n/**\r\n * _reconnect - implement reconnection\r\n * @api privateish\r\n */\r\nMqttClient.prototype._reconnect = function () {\r\n  debug('_reconnect: emitting reconnect to client')\r\n  this.emit('reconnect')\r\n  if (this.connected) {\r\n    this.end(() => { this._setupStream() })\r\n    debug('client already connected. disconnecting first.')\r\n  } else {\r\n    debug('_reconnect: calling _setupStream')\r\n    this._setupStream()\r\n  }\r\n}\r\n\r\n/**\r\n * _setupReconnect - setup reconnect timer\r\n */\r\nMqttClient.prototype._setupReconnect = function () {\r\n  var that = this\r\n\r\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\r\n    if (!this.reconnecting) {\r\n      debug('_setupReconnect :: emit `offline` state')\r\n      this.emit('offline')\r\n      debug('_setupReconnect :: set `reconnecting` to `true`')\r\n      this.reconnecting = true\r\n    }\r\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)\r\n    that.reconnectTimer = setInterval(function () {\r\n      debug('reconnectTimer :: reconnect triggered!')\r\n      that._reconnect()\r\n    }, that.options.reconnectPeriod)\r\n  } else {\r\n    debug('_setupReconnect :: doing nothing...')\r\n  }\r\n}\r\n\r\n/**\r\n * _clearReconnect - clear the reconnect timer\r\n */\r\nMqttClient.prototype._clearReconnect = function () {\r\n  debug('_clearReconnect : clearing reconnect timer')\r\n  if (this.reconnectTimer) {\r\n    clearInterval(this.reconnectTimer)\r\n    this.reconnectTimer = null\r\n  }\r\n}\r\n\r\n/**\r\n * _cleanUp - clean up on connection end\r\n * @api private\r\n */\r\nMqttClient.prototype._cleanUp = function (forced, done) {\r\n  var opts = arguments[2]\r\n  if (done) {\r\n    debug('_cleanUp :: done callback provided for on stream close')\r\n    this.stream.on('close', done)\r\n  }\r\n\r\n  debug('_cleanUp :: forced? %s', forced)\r\n  if (forced) {\r\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\r\n      flush(this.outgoing)\r\n    }\r\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)\r\n    this.stream.destroy()\r\n  } else {\r\n    var packet = xtend({ cmd: 'disconnect' }, opts)\r\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)\r\n    this._sendPacket(\r\n      packet,\r\n      setImmediate.bind(\r\n        null,\r\n        this.stream.end.bind(this.stream)\r\n      )\r\n    )\r\n  }\r\n\r\n  if (!this.disconnecting) {\r\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')\r\n    this._clearReconnect()\r\n    this._setupReconnect()\r\n  }\r\n\r\n  if (this.pingTimer !== null) {\r\n    debug('_cleanUp :: clearing pingTimer')\r\n    this.pingTimer.clear()\r\n    this.pingTimer = null\r\n  }\r\n\r\n  if (done && !this.connected) {\r\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)\r\n    this.stream.removeListener('close', done)\r\n    done()\r\n  }\r\n}\r\n\r\n/**\r\n * _sendPacket - send or queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\r\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\r\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId)\r\n  cbStorePut = cbStorePut || nop\r\n\r\n  if (!this.connected) {\r\n    debug('_sendPacket :: client not connected. Storing packet offline.')\r\n    this._storePacket(packet, cb, cbStorePut)\r\n    return\r\n  }\r\n\r\n  // When sending a packet, reschedule the ping timer\r\n  this._shiftPingInterval()\r\n\r\n  switch (packet.cmd) {\r\n    case 'publish':\r\n      break\r\n    case 'pubrel':\r\n      storeAndSend(this, packet, cb, cbStorePut)\r\n      return\r\n    default:\r\n      sendPacket(this, packet, cb)\r\n      return\r\n  }\r\n\r\n  switch (packet.qos) {\r\n    case 2:\r\n    case 1:\r\n      storeAndSend(this, packet, cb, cbStorePut)\r\n      break\r\n    /**\r\n     * no need of case here since it will be caught by default\r\n     * and jshint comply that before default it must be a break\r\n     * anyway it will result in -1 evaluation\r\n     */\r\n    case 0:\r\n      /* falls through */\r\n    default:\r\n      sendPacket(this, packet, cb)\r\n      break\r\n  }\r\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId)\r\n}\r\n\r\n/**\r\n * _storePacket - queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\r\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\r\n  debug('_storePacket :: packet: %o', packet)\r\n  debug('_storePacket :: cb? %s', !!cb)\r\n  cbStorePut = cbStorePut || nop\r\n\r\n  // check that the packet is not a qos of 0, or that the command is not a publish\r\n  if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\r\n    this.queue.push({ packet: packet, cb: cb })\r\n  } else if (packet.qos > 0) {\r\n    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null\r\n    this.outgoingStore.put(packet, function (err) {\r\n      if (err) {\r\n        return cb && cb(err)\r\n      }\r\n      cbStorePut()\r\n    })\r\n  } else if (cb) {\r\n    cb(new Error('No connection to broker'))\r\n  }\r\n}\r\n\r\n/**\r\n * _setupPingTimer - setup the ping timer\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._setupPingTimer = function () {\r\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)\r\n  var that = this\r\n\r\n  if (!this.pingTimer && this.options.keepalive) {\r\n    this.pingResp = true\r\n    this.pingTimer = reInterval(function () {\r\n      that._checkPing()\r\n    }, this.options.keepalive * 1000)\r\n  }\r\n}\r\n\r\n/**\r\n * _shiftPingInterval - reschedule the ping interval\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._shiftPingInterval = function () {\r\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\r\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\r\n  }\r\n}\r\n/**\r\n * _checkPing - check if a pingresp has come back, and ping the server again\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._checkPing = function () {\r\n  debug('_checkPing :: checking ping...')\r\n  if (this.pingResp) {\r\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')\r\n    this.pingResp = false\r\n    this._sendPacket({ cmd: 'pingreq' })\r\n  } else {\r\n    // do a forced cleanup since socket will be in bad shape\r\n    debug('_checkPing :: calling _cleanUp with force true')\r\n    this._cleanUp(true)\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePingresp - handle a pingresp\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._handlePingresp = function () {\r\n  this.pingResp = true\r\n}\r\n\r\n/**\r\n * _handleConnack\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\nMqttClient.prototype._handleConnack = function (packet) {\r\n  debug('_handleConnack')\r\n  var options = this.options\r\n  var version = options.protocolVersion\r\n  var rc = version === 5 ? packet.reasonCode : packet.returnCode\r\n\r\n  clearTimeout(this.connackTimer)\r\n\r\n  if (packet.properties) {\r\n    if (packet.properties.topicAliasMaximum) {\r\n      if (!options.properties) { options.properties = {} }\r\n      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum\r\n    }\r\n    if (packet.properties.serverKeepAlive && options.keepalive) {\r\n      options.keepalive = packet.properties.serverKeepAlive\r\n      this._shiftPingInterval()\r\n    }\r\n    if (packet.properties.maximumPacketSize) {\r\n      if (!options.properties) { options.properties = {} }\r\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\r\n    }\r\n  }\r\n\r\n  if (rc === 0) {\r\n    this.reconnecting = false\r\n    this._onConnect(packet)\r\n  } else if (rc > 0) {\r\n    var err = new Error('Connection refused: ' + errors[rc])\r\n    err.code = rc\r\n    this.emit('error', err)\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePublish\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\n/*\r\nthose late 2 case should be rewrite to comply with coding style:\r\n\r\ncase 1:\r\ncase 0:\r\n  // do not wait sending a puback\r\n  // no callback passed\r\n  if (1 === qos) {\r\n    this._sendPacket({\r\n      cmd: 'puback',\r\n      messageId: messageId\r\n    });\r\n  }\r\n  // emit the message event for both qos 1 and 0\r\n  this.emit('message', topic, message, packet);\r\n  this.handleMessage(packet, done);\r\n  break;\r\ndefault:\r\n  // do nothing but every switch mus have a default\r\n  // log or throw an error about unknown qos\r\n  break;\r\n\r\nfor now i just suppressed the warnings\r\n*/\r\nMqttClient.prototype._handlePublish = function (packet, done) {\r\n  debug('_handlePublish: packet %o', packet)\r\n  done = typeof done !== 'undefined' ? done : nop\r\n  var topic = packet.topic.toString()\r\n  var message = packet.payload\r\n  var qos = packet.qos\r\n  var messageId = packet.messageId\r\n  var that = this\r\n  var options = this.options\r\n  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\r\n  debug('_handlePublish: qos %d', qos)\r\n  switch (qos) {\r\n    case 2: {\r\n      options.customHandleAcks(topic, message, packet, function (error, code) {\r\n        if (!(error instanceof Error)) {\r\n          code = error\r\n          error = null\r\n        }\r\n        if (error) { return that.emit('error', error) }\r\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\r\n        if (code) {\r\n          that._sendPacket({cmd: 'pubrec', messageId: messageId, reasonCode: code}, done)\r\n        } else {\r\n          that.incomingStore.put(packet, function () {\r\n            that._sendPacket({cmd: 'pubrec', messageId: messageId}, done)\r\n          })\r\n        }\r\n      })\r\n      break\r\n    }\r\n    case 1: {\r\n      // emit the message event\r\n      options.customHandleAcks(topic, message, packet, function (error, code) {\r\n        if (!(error instanceof Error)) {\r\n          code = error\r\n          error = null\r\n        }\r\n        if (error) { return that.emit('error', error) }\r\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\r\n        if (!code) { that.emit('message', topic, message, packet) }\r\n        that.handleMessage(packet, function (err) {\r\n          if (err) {\r\n            return done && done(err)\r\n          }\r\n          that._sendPacket({cmd: 'puback', messageId: messageId, reasonCode: code}, done)\r\n        })\r\n      })\r\n      break\r\n    }\r\n    case 0:\r\n      // emit the message event\r\n      this.emit('message', topic, message, packet)\r\n      this.handleMessage(packet, done)\r\n      break\r\n    default:\r\n      // do nothing\r\n      debug('_handlePublish: unknown QoS. Doing nothing.')\r\n      // log or throw an error about unknown qos\r\n      break\r\n  }\r\n}\r\n\r\n/**\r\n * Handle messages with backpressure support, one at a time.\r\n * Override at will.\r\n *\r\n * @param Packet packet the packet\r\n * @param Function callback call when finished\r\n * @api public\r\n */\r\nMqttClient.prototype.handleMessage = function (packet, callback) {\r\n  callback()\r\n}\r\n\r\n/**\r\n * _handleAck\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\n\r\nMqttClient.prototype._handleAck = function (packet) {\r\n  /* eslint no-fallthrough: \"off\" */\r\n  var messageId = packet.messageId\r\n  var type = packet.cmd\r\n  var response = null\r\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\r\n  var that = this\r\n  var err\r\n\r\n  if (!cb) {\r\n    debug('_handleAck :: Server sent an ack in error. Ignoring.')\r\n    // Server sent an ack in error, ignore it.\r\n    return\r\n  }\r\n\r\n  // Process\r\n  debug('_handleAck :: packet type', type)\r\n  switch (type) {\r\n    case 'pubcomp':\r\n      // same thing as puback for QoS 2\r\n    case 'puback':\r\n      var pubackRC = packet.reasonCode\r\n      // Callback - we're done\r\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\r\n        err = new Error('Publish error: ' + errors[pubackRC])\r\n        err.code = pubackRC\r\n        cb(err, packet)\r\n      }\r\n      delete this.outgoing[messageId]\r\n      this.outgoingStore.del(packet, cb)\r\n      break\r\n    case 'pubrec':\r\n      response = {\r\n        cmd: 'pubrel',\r\n        qos: 2,\r\n        messageId: messageId\r\n      }\r\n      var pubrecRC = packet.reasonCode\r\n\r\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\r\n        err = new Error('Publish error: ' + errors[pubrecRC])\r\n        err.code = pubrecRC\r\n        cb(err, packet)\r\n      } else {\r\n        this._sendPacket(response)\r\n      }\r\n      break\r\n    case 'suback':\r\n      delete this.outgoing[messageId]\r\n      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\r\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\r\n          // suback with Failure status\r\n          var topics = this.messageIdToTopic[messageId]\r\n          if (topics) {\r\n            topics.forEach(function (topic) {\r\n              delete that._resubscribeTopics[topic]\r\n            })\r\n          }\r\n        }\r\n      }\r\n      cb(null, packet)\r\n      break\r\n    case 'unsuback':\r\n      delete this.outgoing[messageId]\r\n      cb(null)\r\n      break\r\n    default:\r\n      that.emit('error', new Error('unrecognized packet type'))\r\n  }\r\n\r\n  if (this.disconnecting &&\r\n      Object.keys(this.outgoing).length === 0) {\r\n    this.emit('outgoingEmpty')\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePubrel\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\nMqttClient.prototype._handlePubrel = function (packet, callback) {\r\n  debug('handling pubrel packet')\r\n  callback = typeof callback !== 'undefined' ? callback : nop\r\n  var messageId = packet.messageId\r\n  var that = this\r\n\r\n  var comp = {cmd: 'pubcomp', messageId: messageId}\r\n\r\n  that.incomingStore.get(packet, function (err, pub) {\r\n    if (!err) {\r\n      that.emit('message', pub.topic, pub.payload, pub)\r\n      that.handleMessage(pub, function (err) {\r\n        if (err) {\r\n          return callback(err)\r\n        }\r\n        that.incomingStore.del(pub, nop)\r\n        that._sendPacket(comp, callback)\r\n      })\r\n    } else {\r\n      that._sendPacket(comp, callback)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * _handleDisconnect\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\nMqttClient.prototype._handleDisconnect = function (packet) {\r\n  this.emit('disconnect', packet)\r\n}\r\n\r\n/**\r\n * _nextId\r\n * @return unsigned int\r\n */\r\nMqttClient.prototype._nextId = function () {\r\n  // id becomes current state of this.nextId and increments afterwards\r\n  var id = this.nextId++\r\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\r\n  if (this.nextId === 65536) {\r\n    this.nextId = 1\r\n  }\r\n  return id\r\n}\r\n\r\n/**\r\n * getLastMessageId\r\n * @return unsigned int\r\n */\r\nMqttClient.prototype.getLastMessageId = function () {\r\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\r\n}\r\n\r\n/**\r\n * _resubscribe\r\n * @api private\r\n */\r\nMqttClient.prototype._resubscribe = function (connack) {\r\n  debug('_resubscribe')\r\n  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\r\n  if (!this._firstConnection &&\r\n      (this.options.clean || (this.options.protocolVersion === 5 && !connack.sessionPresent)) &&\r\n      _resubscribeTopicsKeys.length > 0) {\r\n    if (this.options.resubscribe) {\r\n      if (this.options.protocolVersion === 5) {\r\n        debug('_resubscribe: protocolVersion 5')\r\n        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\r\n          var resubscribeTopic = {}\r\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\r\n          resubscribeTopic.resubscribe = true\r\n          this.subscribe(resubscribeTopic, {properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties})\r\n        }\r\n      } else {\r\n        this._resubscribeTopics.resubscribe = true\r\n        this.subscribe(this._resubscribeTopics)\r\n      }\r\n    } else {\r\n      this._resubscribeTopics = {}\r\n    }\r\n  }\r\n\r\n  this._firstConnection = false\r\n}\r\n\r\n/**\r\n * _onConnect\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._onConnect = function (packet) {\r\n  if (this.disconnected) {\r\n    this.emit('connect', packet)\r\n    return\r\n  }\r\n\r\n  var that = this\r\n\r\n  this._setupPingTimer()\r\n  this._resubscribe(packet)\r\n\r\n  this.connected = true\r\n\r\n  function startStreamProcess () {\r\n    var outStore = that.outgoingStore.createStream()\r\n\r\n    function clearStoreProcessing () {\r\n      that._storeProcessing = false\r\n      that._packetIdsDuringStoreProcessing = {}\r\n    }\r\n\r\n    that.once('close', remove)\r\n    outStore.on('error', function (err) {\r\n      clearStoreProcessing()\r\n      that.removeListener('close', remove)\r\n      that.emit('error', err)\r\n    })\r\n\r\n    function remove () {\r\n      outStore.destroy()\r\n      outStore = null\r\n      clearStoreProcessing()\r\n    }\r\n\r\n    function storeDeliver () {\r\n      // edge case, we wrapped this twice\r\n      if (!outStore) {\r\n        return\r\n      }\r\n      that._storeProcessing = true\r\n\r\n      var packet = outStore.read(1)\r\n\r\n      var cb\r\n\r\n      if (!packet) {\r\n        // read when data is available in the future\r\n        outStore.once('readable', storeDeliver)\r\n        return\r\n      }\r\n\r\n      // Skip already processed store packets\r\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\r\n        storeDeliver()\r\n        return\r\n      }\r\n\r\n      // Avoid unnecessary stream read operations when disconnected\r\n      if (!that.disconnecting && !that.reconnectTimer) {\r\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\r\n        that.outgoing[packet.messageId] = {\r\n          volatile: false,\r\n          cb: function (err, status) {\r\n            // Ensure that the original callback passed in to publish gets invoked\r\n            if (cb) {\r\n              cb(err, status)\r\n            }\r\n\r\n            storeDeliver()\r\n          }\r\n        }\r\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\r\n        that._sendPacket(packet)\r\n      } else if (outStore.destroy) {\r\n        outStore.destroy()\r\n      }\r\n    }\r\n\r\n    outStore.on('end', function () {\r\n      var allProcessed = true\r\n      for (var id in that._packetIdsDuringStoreProcessing) {\r\n        if (!that._packetIdsDuringStoreProcessing[id]) {\r\n          allProcessed = false\r\n          break\r\n        }\r\n      }\r\n      if (allProcessed) {\r\n        clearStoreProcessing()\r\n        that.removeListener('close', remove)\r\n        that.emit('connect', packet)\r\n      } else {\r\n        startStreamProcess()\r\n      }\r\n    })\r\n    storeDeliver()\r\n  }\r\n  // start flowing\r\n  startStreamProcess()\r\n}\r\n\r\nmodule.exports = MqttClient\r\n"]},"metadata":{},"sourceType":"script"}